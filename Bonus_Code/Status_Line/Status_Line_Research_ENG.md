# Claude Code Status Line Research Document
*Complete research on transcripts, JSON fields and existing implementations*

## üìä Complete Analysis of the Transcript File

### Basic Structure of the Transcript
The transcript is a JSONL (JSON Lines) file where each line is a JSON object representing an event in the conversation.

### Types of Messages in the Transcript
- `"summary"`: Conversation summary (1 per session)
- `"user"`: User message (26 in the analyzed file)
- `"assistant"`: Claude response (25 in the analyzed file)

## üîë All Available JSON Fields

### Main Fields (Root Level)

#### 1. **`type`**
- **Description**: Message type
- **Values**: `"summary"`, `"user"`, `"assistant"`
- **Usage**: Filter messages by type

#### 2. **`sessionId`**
- **Description**: Unique ID of the chat session
- **Example**: `"690365b5-f033-44e5-8f7c-f7a11d2cb6bf"`
- **Usage**: Track conversations, filter messages from a specific session

#### 3. **`uuid`**
- **Description**: Unique ID of EVERY single message
- **Example**: `"99c1dd92-5f54-40f4-9643-8bca9155f908"`
- **Usage**: Identify specific messages, create references

#### 4. **`parentUuid`**
- **Description**: UUID of the previous message in the chain
- **Value**: `null` for the first message, otherwise UUID of the parent
- **Usage**: Reconstruct conversation tree, calculate depth

#### 5. **`timestamp`**
- **Description**: ISO timestamp with milliseconds
- **Example**: `"2025-09-05T14:14:14.061Z"`
- **Usage**: Calculate duration between messages, chronological ordering

#### 6. **`cwd`**
- **Description**: Current Working Directory
- **Example**: `"/Users/davide/Python/VAA_Terrel_Webinar"`
- **Usage**: Understand project context

#### 7. **`gitBranch`**
- **Description**: Current Git branch at the time of the message
- **Example**: `"main"`
- **Usage**: Track which branch is being worked on

#### 8. **`version`**
- **Description**: Claude Code version
- **Example**: `"1.0.107"`
- **Usage**: Compatibility, debugging

#### 9. **`userType`**
- **Description**: User type
- **Value**: Always `"external"` for normal users
- **Usage**: Distinguish internal/external users

#### 10. **`isSidechain`**
- **Description**: Indicates if it's a parallel conversation
- **Detailed Explanation**: 
  - `false`: Message in the main work flow
  - `true`: "Side" question that doesn't interrupt the main work
  - Example: While fixing a bug, you ask "what is async?" - this question will have `isSidechain: true`
- **Usage**: Filter secondary questions, maintain focus on main task

#### 11. **`isMeta`**
- **Description**: Indicates system/command messages
- **Values**: 
  - `true`: System messages, commands, metadata
  - `false`: Normal conversation messages
- **Usage**: Filter messages not visible to the user

#### 12. **`requestId`**
- **Description**: API request ID to Anthropic
- **Example**: `"req_011CSqPkHW8dJ7mURR1NjdXw"`
- **Usage**: API debugging, call tracking, error correlation

#### 13. **`leafUuid`**
- **Description**: UUID of the leaf message (only in summary)
- **Usage**: Identify the last message in the chain

### Fields of the `message` Object

#### Basic Structure
```json
"message": {
  "role": "user" | "assistant",
  "content": "string" | [array],
  "id": "msg_...",           // Assistant only
  "model": "claude-opus...",  // Assistant only
  "usage": {...},             // Assistant only
  "stop_reason": null,        // Assistant only
  "stop_sequence": null       // Assistant only
}
```

### `usage` Fields (Assistant Messages Only)

#### Complete Structure with Explanations
```json
"usage": {
  "input_tokens": 4,
  // Tokens passed directly to Claude (cost more)
  
  "cache_creation_input_tokens": 66288,
  // Tokens that are saved in cache for future use
  
  "cache_read_input_tokens": 0,
  // Tokens read from cache (cost 90% less!)
  
  "output_tokens": 50,
  // Tokens generated by Claude in the response
  
  "service_tier": "standard",
  // Service level: "standard" or "premium"
  
  "cache_creation": {
    "ephemeral_5m_input_tokens": 66288,
    // Cache that lasts 5 minutes
    
    "ephemeral_1h_input_tokens": 0
    // Cache that lasts 1 hour (more expensive but lasts longer)
  }
}
```

#### Calculable Metrics from Tokens

1. **Total Tokens in Claude's Head**:
   ```python
   total = input_tokens + cache_creation + cache_read + output_tokens
   ```

2. **Cache Hit Ratio** (Cache Efficiency):
   ```python
   ratio = cache_read / (input_tokens + cache_creation + cache_read) * 100
   ```

3. **Economic Savings**:
   ```python
   saved_money = cache_read * token_price * 0.9  # 90% discount
   ```

4. **Generation Speed**:
   ```python
   tokens_per_second = output_tokens / response_time_seconds
   ```

### `toolUseResult` Fields

#### For Web Fetch
```json
"toolUseResult": {
  "bytes": 2335001,        // Response size
  "code": 200,             // HTTP status code
  "codeText": "OK",        // HTTP status text
  "durationMs": 10923,     // Execution time in milliseconds
  "url": "https://...",    // Requested URL
  "result": "..."          // Response content
}
```

#### For File Operations
```json
"toolUseResult": {
  "file": "/path/to/file",
  "filePath": "/path/to/file",
  "originalFile": "original content",
  "oldString": "old text",
  "newString": "new text",
  "structuredPatch": {...},
  "replaceAll": false,
  "userModified": false,
  "isImage": false
}
```

#### For Todo Management
```json
"toolUseResult": {
  "oldTodos": [
    {"content": "...", "status": "pending", "activeForm": "..."}
  ],
  "newTodos": [
    {"content": "...", "status": "completed", "activeForm": "..."}
  ]
}
```

#### For Bash Commands
```json
"toolUseResult": {
  "stdout": "command output",
  "stderr": "any errors",
  "interrupted": false,
  "type": "bash"
}
```

## üìè Session Depth Explained

### What is Session Depth?
The "session depth" is the number of messages in chain from first to last.

### How It Works
Each message has a `parentUuid` that points to the previous message:

```
Message 1: parentUuid = null      ‚Üí Depth 0 (root)
    ‚Üì
Message 2: parentUuid = uuid-1    ‚Üí Depth 1
    ‚Üì
Message 3: parentUuid = uuid-2    ‚Üí Depth 2
    ‚Üì
Message 4: parentUuid = uuid-3    ‚Üí Depth 3
```

### Why Is It Important?
- **Depth < 10**: Conversation just started
- **Depth 10-30**: Normal conversation
- **Depth 30-50**: Long conversation, possible context issues
- **Depth > 50**: Risk of context loss, consider new session

### Calculation in Python
```python
def calculate_session_depth(transcript, current_message):
    depth = 0
    while current_message['parentUuid'] is not None:
        depth += 1
        # Find the parent message
        for msg in transcript:
            if msg['uuid'] == current_message['parentUuid']:
                current_message = msg
                break
    return depth
```

## üöÄ Advanced Features Discovered

### 1. Tool Performance Tracking
```python
# Extract all tool durations
tool_times = []
for entry in transcript:
    if 'toolUseResult' in entry and 'durationMs' in entry['toolUseResult']:
        tool_times.append({
            'tool': entry.get('toolName'),
            'duration': entry['toolUseResult']['durationMs']
        })

# Calculate averages per tool
avg_by_tool = {}
for t in tool_times:
    if t['tool'] not in avg_by_tool:
        avg_by_tool[t['tool']] = []
    avg_by_tool[t['tool']].append(t['duration'])
```

### 2. Error Rate Monitoring
```python
# Count HTTP errors
http_errors = 0
total_requests = 0

for entry in transcript:
    if 'toolUseResult' in entry and 'code' in entry['toolUseResult']:
        total_requests += 1
        if entry['toolUseResult']['code'] >= 400:
            http_errors += 1

error_rate = (http_errors / total_requests * 100) if total_requests else 0
```

### 3. Cache Efficiency Analysis
```python
def analyze_cache_efficiency(transcript):
    total_cache_hits = 0
    total_cache_misses = 0
    
    for entry in transcript:
        if entry.get('type') == 'assistant':
            usage = entry.get('message', {}).get('usage', {})
            cache_read = usage.get('cache_read_input_tokens', 0)
            direct_input = usage.get('input_tokens', 0)
            
            if cache_read > 0:
                total_cache_hits += cache_read
            if direct_input > 0:
                total_cache_misses += direct_input
    
    hit_ratio = (total_cache_hits / (total_cache_hits + total_cache_misses) * 100) 
                if (total_cache_hits + total_cache_misses) > 0 else 0
    
    return {
        'hit_ratio': hit_ratio,
        'tokens_saved': total_cache_hits,
        'money_saved': total_cache_hits * 0.00003 * 0.9  # Example calculation
    }
```

### 4. Message Chain Analysis
```python
def analyze_message_chains(transcript):
    # Find all sidechains
    sidechains = []
    main_chain = []
    
    for entry in transcript:
        if entry.get('isSidechain'):
            sidechains.append(entry)
        else:
            main_chain.append(entry)
    
    return {
        'main_chain_length': len(main_chain),
        'sidechain_count': len(sidechains),
        'sidechain_percentage': (len(sidechains) / len(transcript) * 100) 
                                if transcript else 0
    }
```

## üåü Status Line Repositories for Claude Code

### Specific Repositories for Claude Code

#### 1. **ccstatusline** by sirmalloc
- **URL**: https://github.com/sirmalloc/ccstatusline
- **Language**: JavaScript/TypeScript
- **Main Features**:
  - Interactive TUI with React/Ink
  - Cross-platform (Bun and Node.js)
  - Git worktree widget
  - Token usage tracking
  - Emoji support
  - Zero config

#### 2. **claude-statusline** by ersinkoc
- **URL**: https://github.com/ersinkoc/claude-statusline
- **Language**: Python
- **Main Features**:
  - 100+ Powerline themes
  - Interactive theme browser
  - Real-time cost tracking
  - Multi-model support
  - Advanced RGB system

#### 3. **pyccsl** (Python Claude Code Status Line)
- **URL**: https://github.com/wolfdenpublishing/pyccsl
- **Language**: Python
- **Main Features**:
  - Single file (~1000 lines)
  - Zero external dependencies
  - Cache hit rate display
  - Response time tracking
  - Token generation speed (tok/s)

#### 4. **cc-statusline** by chongdashu
- **URL**: https://github.com/chongdashu/cc-statusline
- **Language**: Python
- **Main Features**:
  - Real-time directory tracking
  - Git branch display
  - Cost monitoring
  - Session time tracking

#### 5. **claude_monitor_statusline**
- **URL**: https://github.com/gabriel-dehan/claude_monitor_statusline
- **Language**: Ruby
- **Main Features**:
  - Workspace context display
  - Git status with change indicators (+5 -2)
  - Token/message usage with plan limits
  - Customizable

## üí° Ideas for Status Line Improvements

### Features to Implement Immediately

#### 1. Tool Performance Monitor
```python
# Show average tool performance
parts.append(f"‚ö° Tools: {avg_tool_time:.1f}s")
```

#### 2. Error Rate Display
```python
# Show error rate
parts.append(f"‚ùå Errors: {error_rate:.1f}%")
```

#### 3. Cache Savings Calculator
```python
# Show economic savings from cache
parts.append(f"üíµ Saved: ${cache_savings:.3f}")
```

#### 4. Token Generation Speed
```python
# Token generation speed
parts.append(f"‚ö° {tokens_per_second:.0f} tok/s")
```

#### 5. Session Depth Indicator
```python
# Conversation depth
parts.append(f"üîó Depth: {session_depth}")
```

#### 6. Sidechain Indicator
```python
# If in a parallel conversation
if is_sidechain:
    parts.append("üåø [sidechain]")
```

#### 7. Service Tier Display
```python
# Show service tier
parts.append(f"üéØ Tier: {service_tier}")
```

#### 8. Ephemeral Cache Status
```python
# Temporary cache status
parts.append(f"üíæ 5m: {ephemeral_5m}k | 1h: {ephemeral_1h}k")
```

### Advanced Features to Consider

1. **Interactive Mode**: Click on status line to see details
2. **Theme System**: Support for customizable themes
3. **Alert System**: Notifications when thresholds are exceeded (cost, tokens, errors)
4. **History Graph**: ASCII graph of usage over time
5. **Multi-Session Support**: Track multiple sessions simultaneously
6. **Export Metrics**: Save metrics for later analysis
7. **Plugin System**: Allow custom extensions

## üìö Useful Libraries for Implementation

### Python
- **Rich**: https://github.com/Textualize/rich - Advanced formatting
- **Textual**: https://github.com/Textualize/textual - Complex TUI
- **prompt-toolkit**: https://github.com/prompt-toolkit/python-prompt-toolkit - Interactive CLI
- **tqdm**: https://github.com/tqdm/tqdm - Efficient progress bars
- **alive-progress**: https://pypi.org/project/alive-progress/ - Animated progress bars

### JavaScript/Node.js
- **Ora**: https://github.com/sindresorhus/ora - Terminal spinners
- **Chalk**: https://github.com/chalk/chalk - Text styling
- **Terminal-kit**: https://github.com/cronvel/terminal-kit - Complete utilities
- **Ink**: https://github.com/vadimdemedes/ink - React for CLI

### Rust
- **Ratatui**: https://github.com/ratatui/ratatui - TUI framework
- **Indicatif**: https://github.com/console-rs/indicatif - Progress reporting

### Go
- **Bubble Tea**: https://github.com/charmbracelet/bubbletea - TUI framework
- **Lipgloss**: https://github.com/charmbracelet/lipgloss - Styling

## üéØ Conclusions and Recommendations

### Key Discoveries
1. The transcript contains MANY more data points than documented
2. The status line can read any file/command to enrich itself
3. Excellent implementations already exist to draw inspiration from
4. Cache efficiency is crucial for cost savings

### Immediate Recommendations
1. **Implement error tracking** - Important for debugging
2. **Add cache savings display** - Show the value of caching
3. **Use session depth** - Prevent context issues
4. **Monitor tool performance** - Identify bottlenecks

### Next Steps
1. Study existing repositories for best practices
2. Implement features incrementally
3. Consider a theme system
4. Add performance metrics
5. Create user documentation

---

*Document created on 2025-09-05 by Claude Code*

---

**Author**: Russo Davide (The DaveEloper)  
**Email**: vibecoding@pcok.it  
**Project**: ChatTokener Suite  
**Component**: VAA Bonus - Status Line Research
*Based on transcript file analysis and online research of existing implementations*